<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SubmissionService/src/main/java/com/Submission/SubmissionService/service/PistonApiService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SubmissionService/src/main/java/com/Submission/SubmissionService/service/PistonApiService.java" />
              <option name="originalContent" value="package com.Submission.SubmissionService.service;&#10;&#10;import com.Submission.SubmissionService.dto.PistonRuntimeResponse;&#10;import com.Submission.SubmissionService.dto.RunCodeRequest;&#10;import com.Submission.SubmissionService.dto.RunCodeResponse;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.core.ParameterizedTypeReference;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;import java.util.*;&#10;&#10;@Service&#10;@Slf4j&#10;public class PistonApiService {&#10;&#10;    @Value(&quot;${piston.api.url:https://emkc.org/api/v2/piston}&quot;)&#10;    private String pistonApiUrl;&#10;&#10;    private final RestTemplate restTemplate;&#10;&#10;    public PistonApiService() {&#10;        this.restTemplate = new RestTemplate();&#10;    }&#10;&#10;    /**&#10;     * Get list of available runtimes from Piston&#10;     */&#10;    public List&lt;PistonRuntimeResponse&gt; getRuntimes() {&#10;        try {&#10;            log.info(&quot;Fetching available runtimes from Piston API&quot;);&#10;            String url = pistonApiUrl + &quot;/runtimes&quot;;&#10;&#10;            ResponseEntity&lt;List&lt;PistonRuntimeResponse&gt;&gt; response = restTemplate.exchange(&#10;                url,&#10;                HttpMethod.GET,&#10;                null,&#10;                new ParameterizedTypeReference&lt;List&lt;PistonRuntimeResponse&gt;&gt;() {}&#10;            );&#10;&#10;            log.info(&quot;Successfully fetched {} runtimes&quot;, response.getBody() != null ? response.getBody().size() : 0);&#10;            return response.getBody();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error fetching runtimes from Piston API: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Failed to fetch runtimes: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute code using Piston API&#10;     */&#10;    public RunCodeResponse executeCode(RunCodeRequest request) {&#10;        try {&#10;            log.info(&quot;Executing {} code via Piston API&quot;, request.getLanguage());&#10;&#10;            // Prepare the request payload for Piston&#10;            Map&lt;String, Object&gt; pistonRequest = new HashMap&lt;&gt;();&#10;            pistonRequest.put(&quot;language&quot;, mapLanguageToPiston(request.getLanguage()));&#10;&#10;            if (request.getVersion() != null &amp;&amp; !request.getVersion().isEmpty()) {&#10;                pistonRequest.put(&quot;version&quot;, request.getVersion());&#10;            }&#10;&#10;            // Create files array with the code&#10;            List&lt;Map&lt;String, String&gt;&gt; files = new ArrayList&lt;&gt;();&#10;            Map&lt;String, String&gt; file = new HashMap&lt;&gt;();&#10;            file.put(&quot;name&quot;, getDefaultFileName(request.getLanguage()));&#10;            file.put(&quot;content&quot;, request.getCode());&#10;            files.add(file);&#10;            pistonRequest.put(&quot;files&quot;, files);&#10;&#10;            // Add optional parameters&#10;            if (request.getStdin() != null) {&#10;                pistonRequest.put(&quot;stdin&quot;, request.getStdin());&#10;            }&#10;            if (request.getArgs() != null &amp;&amp; !request.getArgs().isEmpty()) {&#10;                pistonRequest.put(&quot;args&quot;, request.getArgs());&#10;            }&#10;            if (request.getRunTimeout() != null) {&#10;                pistonRequest.put(&quot;run_timeout&quot;, request.getRunTimeout());&#10;            } else {&#10;                pistonRequest.put(&quot;run_timeout&quot;, 3000); // Default 3 seconds&#10;            }&#10;            if (request.getCompileTimeout() != null) {&#10;                pistonRequest.put(&quot;compile_timeout&quot;, request.getCompileTimeout());&#10;            } else {&#10;                pistonRequest.put(&quot;compile_timeout&quot;, 10000); // Default 10 seconds&#10;            }&#10;            if (request.getCompileMemoryLimit() != null) {&#10;                pistonRequest.put(&quot;compile_memory_limit&quot;, request.getCompileMemoryLimit());&#10;            } else {&#10;                pistonRequest.put(&quot;compile_memory_limit&quot;, -1); // No limit&#10;            }&#10;            if (request.getRunMemoryLimit() != null) {&#10;                pistonRequest.put(&quot;run_memory_limit&quot;, request.getRunMemoryLimit());&#10;            } else {&#10;                pistonRequest.put(&quot;run_memory_limit&quot;, -1); // No limit&#10;            }&#10;&#10;            log.debug(&quot;Piston request: {}&quot;, pistonRequest);&#10;&#10;            // Make the API call&#10;            String url = pistonApiUrl + &quot;/execute&quot;;&#10;            HttpHeaders headers = new HttpHeaders();&#10;            headers.setContentType(MediaType.APPLICATION_JSON);&#10;            HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(pistonRequest, headers);&#10;&#10;            ResponseEntity&lt;Map&gt; response = restTemplate.exchange(&#10;                url,&#10;                HttpMethod.POST,&#10;                entity,&#10;                Map.class&#10;            );&#10;&#10;            // Parse the response&#10;            Map&lt;String, Object&gt; responseBody = response.getBody();&#10;            if (responseBody == null) {&#10;                throw new RuntimeException(&quot;Empty response from Piston API&quot;);&#10;            }&#10;&#10;            log.info(&quot;Code execution completed. Language: {}, Version: {}&quot;,&#10;                responseBody.get(&quot;language&quot;), responseBody.get(&quot;version&quot;));&#10;&#10;            return mapPistonResponse(responseBody);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error executing code via Piston API: {}&quot;, e.getMessage(), e);&#10;&#10;            // Return error response&#10;            RunCodeResponse errorResponse = new RunCodeResponse();&#10;            errorResponse.setMessage(&quot;Execution failed: &quot; + e.getMessage());&#10;&#10;            RunCodeResponse.RunResult runResult = new RunCodeResponse.RunResult();&#10;            runResult.setStderr(e.getMessage());&#10;            runResult.setCode(1);&#10;            errorResponse.setRun(runResult);&#10;&#10;            return errorResponse;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Map language names to Piston-compatible names&#10;     */&#10;    private String mapLanguageToPiston(String language) {&#10;        Map&lt;String, String&gt; languageMap = new HashMap&lt;&gt;();&#10;        languageMap.put(&quot;javascript&quot;, &quot;javascript&quot;);&#10;        languageMap.put(&quot;js&quot;, &quot;javascript&quot;);&#10;        languageMap.put(&quot;python&quot;, &quot;python&quot;);&#10;        languageMap.put(&quot;py&quot;, &quot;python&quot;);&#10;        languageMap.put(&quot;java&quot;, &quot;java&quot;);&#10;        languageMap.put(&quot;cpp&quot;, &quot;c++&quot;);&#10;        languageMap.put(&quot;c++&quot;, &quot;c++&quot;);&#10;        languageMap.put(&quot;c&quot;, &quot;c&quot;);&#10;        languageMap.put(&quot;csharp&quot;, &quot;csharp&quot;);&#10;        languageMap.put(&quot;c#&quot;, &quot;csharp&quot;);&#10;        languageMap.put(&quot;go&quot;, &quot;go&quot;);&#10;        languageMap.put(&quot;rust&quot;, &quot;rust&quot;);&#10;        languageMap.put(&quot;ruby&quot;, &quot;ruby&quot;);&#10;        languageMap.put(&quot;php&quot;, &quot;php&quot;);&#10;        languageMap.put(&quot;typescript&quot;, &quot;typescript&quot;);&#10;        languageMap.put(&quot;ts&quot;, &quot;typescript&quot;);&#10;        languageMap.put(&quot;kotlin&quot;, &quot;kotlin&quot;);&#10;        languageMap.put(&quot;swift&quot;, &quot;swift&quot;);&#10;&#10;        return languageMap.getOrDefault(language.toLowerCase(), language.toLowerCase());&#10;    }&#10;&#10;    /**&#10;     * Get default file name based on language&#10;     */&#10;    private String getDefaultFileName(String language) {&#10;        Map&lt;String, String&gt; fileNames = new HashMap&lt;&gt;();&#10;        fileNames.put(&quot;javascript&quot;, &quot;main.js&quot;);&#10;        fileNames.put(&quot;js&quot;, &quot;main.js&quot;);&#10;        fileNames.put(&quot;python&quot;, &quot;main.py&quot;);&#10;        fileNames.put(&quot;py&quot;, &quot;main.py&quot;);&#10;        fileNames.put(&quot;java&quot;, &quot;Main.java&quot;);&#10;        fileNames.put(&quot;cpp&quot;, &quot;main.cpp&quot;);&#10;        fileNames.put(&quot;c++&quot;, &quot;main.cpp&quot;);&#10;        fileNames.put(&quot;c&quot;, &quot;main.c&quot;);&#10;        fileNames.put(&quot;csharp&quot;, &quot;main.cs&quot;);&#10;        fileNames.put(&quot;c#&quot;, &quot;main.cs&quot;);&#10;        fileNames.put(&quot;go&quot;, &quot;main.go&quot;);&#10;        fileNames.put(&quot;rust&quot;, &quot;main.rs&quot;);&#10;        fileNames.put(&quot;ruby&quot;, &quot;main.rb&quot;);&#10;        fileNames.put(&quot;php&quot;, &quot;main.php&quot;);&#10;        fileNames.put(&quot;typescript&quot;, &quot;main.ts&quot;);&#10;        fileNames.put(&quot;ts&quot;, &quot;main.ts&quot;);&#10;        fileNames.put(&quot;kotlin&quot;, &quot;main.kt&quot;);&#10;        fileNames.put(&quot;swift&quot;, &quot;main.swift&quot;);&#10;&#10;        return fileNames.getOrDefault(language.toLowerCase(), &quot;main.txt&quot;);&#10;    }&#10;&#10;    /**&#10;     * Map Piston API response to our response DTO&#10;     */&#10;    private RunCodeResponse mapPistonResponse(Map&lt;String, Object&gt; pistonResponse) {&#10;        RunCodeResponse response = new RunCodeResponse();&#10;        response.setLanguage((String) pistonResponse.get(&quot;language&quot;));&#10;        response.setVersion((String) pistonResponse.get(&quot;version&quot;));&#10;        response.setMessage((String) pistonResponse.get(&quot;message&quot;));&#10;&#10;        // Map run results&#10;        if (pistonResponse.containsKey(&quot;run&quot;)) {&#10;            Map&lt;String, Object&gt; runData = (Map&lt;String, Object&gt;) pistonResponse.get(&quot;run&quot;);&#10;            RunCodeResponse.RunResult runResult = new RunCodeResponse.RunResult();&#10;            runResult.setStdout((String) runData.get(&quot;stdout&quot;));&#10;            runResult.setStderr((String) runData.get(&quot;stderr&quot;));&#10;            runResult.setOutput((String) runData.get(&quot;output&quot;));&#10;            runResult.setCode((Integer) runData.get(&quot;code&quot;));&#10;            runResult.setSignal((String) runData.get(&quot;signal&quot;));&#10;            response.setRun(runResult);&#10;        }&#10;&#10;        // Map compile results (if present)&#10;        if (pistonResponse.containsKey(&quot;compile&quot;)) {&#10;            Map&lt;String, Object&gt; compileData = (Map&lt;String, Object&gt;) pistonResponse.get(&quot;compile&quot;);&#10;            RunCodeResponse.CompileResult compileResult = new RunCodeResponse.CompileResult();&#10;            compileResult.setStdout((String) compileData.get(&quot;stdout&quot;));&#10;            compileResult.setStderr((String) compileData.get(&quot;stderr&quot;));&#10;            compileResult.setOutput((String) compileData.get(&quot;output&quot;));&#10;            compileResult.setCode((Integer) compileData.get(&quot;code&quot;));&#10;            compileResult.setSignal((String) compileData.get(&quot;signal&quot;));&#10;            response.setCompile(compileResult);&#10;        }&#10;&#10;        return response;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.Submission.SubmissionService.service;&#10;&#10;import com.Submission.SubmissionService.dto.PistonRuntimeResponse;&#10;import com.Submission.SubmissionService.dto.RunCodeRequest;&#10;import com.Submission.SubmissionService.dto.RunCodeResponse;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.core.ParameterizedTypeReference;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;import java.util.*;&#10;import java.util.concurrent.locks.Lock;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;@Service&#10;@Slf4j&#10;public class PistonApiService {&#10;&#10;    @Value(&quot;${piston.api.url:https://emkc.org/api/v2/piston}&quot;)&#10;    private String pistonApiUrl;&#10;&#10;    private final RestTemplate restTemplate;&#10;    private final Lock rateLimitLock = new ReentrantLock();&#10;    private long lastRequestTime = 0;&#10;    private static final long MIN_REQUEST_INTERVAL_MS = 250; // 250ms to be safe (API limit is 200ms)&#10;&#10;    public PistonApiService() {&#10;        this.restTemplate = new RestTemplate();&#10;    }&#10;&#10;    /**&#10;     * Enforce rate limiting for Piston API (1 request per 200ms)&#10;     */&#10;    private void enforceRateLimit() {&#10;        rateLimitLock.lock();&#10;        try {&#10;            long currentTime = System.currentTimeMillis();&#10;            long timeSinceLastRequest = currentTime - lastRequestTime;&#10;&#10;            if (timeSinceLastRequest &lt; MIN_REQUEST_INTERVAL_MS) {&#10;                long waitTime = MIN_REQUEST_INTERVAL_MS - timeSinceLastRequest;&#10;                log.debug(&quot;Rate limiting: waiting {}ms before next request&quot;, waitTime);&#10;                try {&#10;                    Thread.sleep(waitTime);&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt();&#10;                    log.warn(&quot;Rate limit wait interrupted&quot;, e);&#10;                }&#10;            }&#10;&#10;            lastRequestTime = System.currentTimeMillis();&#10;        } finally {&#10;            rateLimitLock.unlock();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get list of available runtimes from Piston&#10;     */&#10;    public List&lt;PistonRuntimeResponse&gt; getRuntimes() {&#10;        try {&#10;            log.info(&quot;Fetching available runtimes from Piston API&quot;);&#10;            enforceRateLimit();&#10;            String url = pistonApiUrl + &quot;/runtimes&quot;;&#10;&#10;            ResponseEntity&lt;List&lt;PistonRuntimeResponse&gt;&gt; response = restTemplate.exchange(&#10;                    url,&#10;                    HttpMethod.GET,&#10;                    null,&#10;                    new ParameterizedTypeReference&lt;List&lt;PistonRuntimeResponse&gt;&gt;() {&#10;                    }&#10;            );&#10;&#10;            log.info(&quot;Successfully fetched {} runtimes&quot;, response.getBody() != null ? response.getBody().size() : 0);&#10;            return response.getBody();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error fetching runtimes from Piston API: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Failed to fetch runtimes: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute code using Piston API&#10;     */&#10;    public RunCodeResponse executeCode(RunCodeRequest request) {&#10;        try {&#10;            log.info(&quot;Executing {} code via Piston API&quot;, request.getLanguage());&#10;&#10;            // Enforce rate limiting&#10;            enforceRateLimit();&#10;&#10;            // Prepare the request payload for Piston&#10;            Map&lt;String, Object&gt; pistonRequest = new HashMap&lt;&gt;();&#10;            pistonRequest.put(&quot;language&quot;, mapLanguageToPiston(request.getLanguage()));&#10;&#10;            // Version is REQUIRED by Piston API - use provided or default to &quot;*&quot; (latest)&#10;            String version = (request.getVersion() != null &amp;&amp; !request.getVersion().isEmpty())&#10;                    ? request.getVersion()&#10;                    : &quot;*&quot;;&#10;            pistonRequest.put(&quot;version&quot;, version);&#10;&#10;            // Create files array with the code&#10;            List&lt;Map&lt;String, String&gt;&gt; files = new ArrayList&lt;&gt;();&#10;            Map&lt;String, String&gt; file = new HashMap&lt;&gt;();&#10;            file.put(&quot;name&quot;, getDefaultFileName(request.getLanguage()));&#10;            file.put(&quot;content&quot;, request.getCode());&#10;            files.add(file);&#10;            pistonRequest.put(&quot;files&quot;, files);&#10;&#10;            // Add optional parameters&#10;            if (request.getStdin() != null) {&#10;                pistonRequest.put(&quot;stdin&quot;, request.getStdin());&#10;            } else {&#10;                pistonRequest.put(&quot;stdin&quot;, &quot;&quot;);&#10;            }&#10;            if (request.getArgs() != null &amp;&amp; !request.getArgs().isEmpty()) {&#10;                pistonRequest.put(&quot;args&quot;, request.getArgs());&#10;            }&#10;            if (request.getRunTimeout() != null) {&#10;                pistonRequest.put(&quot;run_timeout&quot;, request.getRunTimeout());&#10;            } else {&#10;                pistonRequest.put(&quot;run_timeout&quot;, 3000); // Default 3 seconds&#10;            }&#10;            if (request.getCompileTimeout() != null) {&#10;                pistonRequest.put(&quot;compile_timeout&quot;, request.getCompileTimeout());&#10;            } else {&#10;                pistonRequest.put(&quot;compile_timeout&quot;, 10000); // Default 10 seconds&#10;            }&#10;            if (request.getCompileMemoryLimit() != null) {&#10;                pistonRequest.put(&quot;compile_memory_limit&quot;, request.getCompileMemoryLimit());&#10;            } else {&#10;                pistonRequest.put(&quot;compile_memory_limit&quot;, -1); // No limit&#10;            }&#10;            if (request.getRunMemoryLimit() != null) {&#10;                pistonRequest.put(&quot;run_memory_limit&quot;, request.getRunMemoryLimit());&#10;            } else {&#10;                pistonRequest.put(&quot;run_memory_limit&quot;, -1); // No limit&#10;            }&#10;&#10;            log.debug(&quot;Piston request: {}&quot;, pistonRequest);&#10;&#10;            // Make the API call&#10;            String url = pistonApiUrl + &quot;/execute&quot;;&#10;            HttpHeaders headers = new HttpHeaders();&#10;            headers.setContentType(MediaType.APPLICATION_JSON);&#10;            HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(pistonRequest, headers);&#10;&#10;            ResponseEntity&lt;Map&gt; response = restTemplate.exchange(&#10;                    url,&#10;                    HttpMethod.POST,&#10;                    entity,&#10;                    Map.class&#10;            );&#10;&#10;            // Parse the response&#10;            Map&lt;String, Object&gt; responseBody = response.getBody();&#10;            if (responseBody == null) {&#10;                throw new RuntimeException(&quot;Empty response from Piston API&quot;);&#10;            }&#10;&#10;            log.info(&quot;Code execution completed. Language: {}, Version: {}&quot;,&#10;                    responseBody.get(&quot;language&quot;), responseBody.get(&quot;version&quot;));&#10;&#10;            return mapPistonResponse(responseBody);&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error executing code via Piston API: {}&quot;, e.getMessage(), e);&#10;&#10;            // Return error response&#10;            RunCodeResponse errorResponse = new RunCodeResponse();&#10;            errorResponse.setMessage(&quot;Execution failed: &quot; + e.getMessage());&#10;&#10;            RunCodeResponse.RunResult runResult = new RunCodeResponse.RunResult();&#10;            runResult.setStderr(e.getMessage());&#10;            runResult.setCode(1);&#10;            errorResponse.setRun(runResult);&#10;&#10;            return errorResponse;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Map language names to Piston-compatible names&#10;     */&#10;    private String mapLanguageToPiston(String language) {&#10;        Map&lt;String, String&gt; languageMap = new HashMap&lt;&gt;();&#10;        languageMap.put(&quot;javascript&quot;, &quot;javascript&quot;);&#10;        languageMap.put(&quot;js&quot;, &quot;javascript&quot;);&#10;        languageMap.put(&quot;python&quot;, &quot;python&quot;);&#10;        languageMap.put(&quot;py&quot;, &quot;python&quot;);&#10;        languageMap.put(&quot;java&quot;, &quot;java&quot;);&#10;        languageMap.put(&quot;cpp&quot;, &quot;c++&quot;);&#10;        languageMap.put(&quot;c++&quot;, &quot;c++&quot;);&#10;        languageMap.put(&quot;c&quot;, &quot;c&quot;);&#10;        languageMap.put(&quot;csharp&quot;, &quot;csharp&quot;);&#10;        languageMap.put(&quot;c#&quot;, &quot;csharp&quot;);&#10;        languageMap.put(&quot;go&quot;, &quot;go&quot;);&#10;        languageMap.put(&quot;rust&quot;, &quot;rust&quot;);&#10;        languageMap.put(&quot;ruby&quot;, &quot;ruby&quot;);&#10;        languageMap.put(&quot;php&quot;, &quot;php&quot;);&#10;        languageMap.put(&quot;typescript&quot;, &quot;typescript&quot;);&#10;        languageMap.put(&quot;ts&quot;, &quot;typescript&quot;);&#10;        languageMap.put(&quot;kotlin&quot;, &quot;kotlin&quot;);&#10;        languageMap.put(&quot;swift&quot;, &quot;swift&quot;);&#10;&#10;        return languageMap.getOrDefault(language.toLowerCase(), language.toLowerCase());&#10;    }&#10;&#10;    /**&#10;     * Get default file name based on language&#10;     */&#10;    private String getDefaultFileName(String language) {&#10;        Map&lt;String, String&gt; fileNames = new HashMap&lt;&gt;();&#10;        fileNames.put(&quot;javascript&quot;, &quot;main.js&quot;);&#10;        fileNames.put(&quot;js&quot;, &quot;main.js&quot;);&#10;        fileNames.put(&quot;python&quot;, &quot;main.py&quot;);&#10;        fileNames.put(&quot;py&quot;, &quot;main.py&quot;);&#10;        fileNames.put(&quot;java&quot;, &quot;Main.java&quot;);&#10;        fileNames.put(&quot;cpp&quot;, &quot;main.cpp&quot;);&#10;        fileNames.put(&quot;c++&quot;, &quot;main.cpp&quot;);&#10;        fileNames.put(&quot;c&quot;, &quot;main.c&quot;);&#10;        fileNames.put(&quot;csharp&quot;, &quot;main.cs&quot;);&#10;        fileNames.put(&quot;c#&quot;, &quot;main.cs&quot;);&#10;        fileNames.put(&quot;go&quot;, &quot;main.go&quot;);&#10;        fileNames.put(&quot;rust&quot;, &quot;main.rs&quot;);&#10;        fileNames.put(&quot;ruby&quot;, &quot;main.rb&quot;);&#10;        fileNames.put(&quot;php&quot;, &quot;main.php&quot;);&#10;        fileNames.put(&quot;typescript&quot;, &quot;main.ts&quot;);&#10;        fileNames.put(&quot;ts&quot;, &quot;main.ts&quot;);&#10;        fileNames.put(&quot;kotlin&quot;, &quot;main.kt&quot;);&#10;        fileNames.put(&quot;swift&quot;, &quot;main.swift&quot;);&#10;&#10;        return fileNames.getOrDefault(language.toLowerCase(), &quot;main.txt&quot;);&#10;    }&#10;&#10;    /**&#10;     * Map Piston API response to our response DTO&#10;     */&#10;    private RunCodeResponse mapPistonResponse(Map&lt;String, Object&gt; pistonResponse) {&#10;        RunCodeResponse response = new RunCodeResponse();&#10;        response.setLanguage((String) pistonResponse.get(&quot;language&quot;));&#10;        response.setVersion((String) pistonResponse.get(&quot;version&quot;));&#10;        response.setMessage((String) pistonResponse.get(&quot;message&quot;));&#10;&#10;        // Map run results&#10;        if (pistonResponse.containsKey(&quot;run&quot;)) {&#10;            Map&lt;String, Object&gt; runData = (Map&lt;String, Object&gt;) pistonResponse.get(&quot;run&quot;);&#10;            RunCodeResponse.RunResult runResult = new RunCodeResponse.RunResult();&#10;            runResult.setStdout((String) runData.get(&quot;stdout&quot;));&#10;            runResult.setStderr((String) runData.get(&quot;stderr&quot;));&#10;            runResult.setOutput((String) runData.get(&quot;output&quot;));&#10;            runResult.setCode((Integer) runData.get(&quot;code&quot;));&#10;            runResult.setSignal((String) runData.get(&quot;signal&quot;));&#10;            response.setRun(runResult);&#10;        }&#10;&#10;        // Map compile results (if present)&#10;        if (pistonResponse.containsKey(&quot;compile&quot;)) {&#10;            Map&lt;String, Object&gt; compileData = (Map&lt;String, Object&gt;) pistonResponse.get(&quot;compile&quot;);&#10;            RunCodeResponse.CompileResult compileResult = new RunCodeResponse.CompileResult();&#10;            compileResult.setStdout((String) compileData.get(&quot;stdout&quot;));&#10;            compileResult.setStderr((String) compileData.get(&quot;stderr&quot;));&#10;            compileResult.setOutput((String) compileData.get(&quot;output&quot;));&#10;            compileResult.setCode((Integer) compileData.get(&quot;code&quot;));&#10;            compileResult.setSignal((String) compileData.get(&quot;signal&quot;));&#10;            response.setCompile(compileResult);&#10;        }&#10;&#10;        return response;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>